{"version":3,"sources":["webpack://reactDiffView/webpack/universalModuleDefinition","webpack://reactDiffView/webpack/bootstrap","webpack://reactDiffView/./node_modules/warning/warning.js","webpack://reactDiffView/./node_modules/gitdiff-parser/index.js","webpack://reactDiffView/./src/parse.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","warning","parser","parse","source","currentInfo","currentHunk","changeOldLine","changeNewLine","infos","stat","lines","split","linesLen","length","line","indexOf","filesStr","slice","oldPath","newPath","segs","nextQuoteIndex","newQuoteIndex","hunks","oldEndingNewLine","newEndingNewLine","push","simiLine","currentInfoType","nextLine","oldMode","newMode","similarity","parseInt","simiLoop","revs","oldRevision","newRevision","oldFileName","newFileName","test","type","isBinary","match","exec","content","oldStart","newStart","oldLines","newLines","changes","typeChar","change","isInsert","lineNumber","isDelete","isNormal","oldLineNumber","newLineNumber","lastChange","mapHunk","hunk","options","nearbySequences","_changes$reduce","reduce","_ref","current","_ref2","_slicedToArray","result","last","lastDeletionIndex","splice","zipChanges","_extends","isPlain","addStubHunk","parseDiff","text","arguments","undefined","_warning2","default","stubHunk","diffText","indexOfFirstLineBreak","indexOfSecondLineBreak","firstLine","secondLine","join","normalizeDiffText","map","file","mapFile","referenceCodeOrLines","linesOfCode","lastHunk","lastLineNumber","_hunks","concat","_toConsumableArray"],"mappings":"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","file":"parse.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"reactDiffView\"] = factory();\n\telse\n\t\troot[\"reactDiffView\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 60);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule warning\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","/**\n * @file gitdiff 消息解析器\n * @author errorrik(errorrik@gmail.com)\n */\n\n(function (root) {\n    var STAT_START = 2;\n    var STAT_FILE_META = 3;\n    var STAT_HUNK = 5;\n\n\n\n\n    var parser = {\n        /**\n         * 解析 gitdiff 消息\n         *\n         * @param {string} source gitdiff消息内容\n         * @return {Object}\n         */\n        parse: function (source) {\n            var infos = [];\n            var stat = STAT_START;\n            var currentInfo;\n            var currentHunk;\n            var changeOldLine;\n            var changeNewLine;\n\n\n            var lines = source.split('\\n');\n            var linesLen = lines.length;\n            var i = 0;\n\n            while (i < linesLen) {\n                var line = lines[i];\n\n                if (line.indexOf('diff --git') === 0) {\n                    var filesStr = line.slice(11);\n                    var oldPath = null;\n                    var newPath = null;\n\n                    var quoteIndex = filesStr.indexOf('\"');\n                    switch (quoteIndex) {\n                        case -1:\n                            var segs = filesStr.split(' ');\n                            oldPath = segs[0].slice(2);\n                            newPath = segs[1].slice(2);\n                            break;\n\n                        case 0:\n                            var nextQuoteIndex = filesStr.indexOf('\"', 2);\n                            oldPath = filesStr.slice(3, nextQuoteIndex);\n                            var newQuoteIndex = filesStr.indexOf('\"', nextQuoteIndex + 1);\n                            if (newQuoteIndex < 0) {\n                                newPath = filesStr.slice(nextQuoteIndex + 4);\n                            }\n                            else {\n                                newPath = filesStr.slice(newQuoteIndex + 3, -1);\n                            }\n                            break;\n\n                        default:\n                            var segs = filesStr.split(' ');\n                            oldPath = segs[0].slice(2);\n                            newPath = segs[1].slice(3, -1);\n                            break;\n                    }\n\n\n                    // read file\n                    currentInfo = {\n                        oldPath: oldPath,\n                        newPath: newPath,\n                        hunks: [],\n                        oldEndingNewLine: true,\n                        newEndingNewLine: true\n                    };\n\n                    infos.push(currentInfo);\n\n\n                    // 1. 如果oldPath是/dev/null就是add\n                    // 2. 如果newPath是/dev/null就是delete\n                    // 3. 如果有 rename from foo.js 这样的就是rename\n                    // 4. 如果有 copy from foo.js 这样的就是copy\n                    // 5. 其它情况是modify\n                    var currentInfoType = null;\n\n                    // read mode change\n                    var nextLine = lines[i + 1];\n                    if (nextLine.indexOf('old') === 0) {\n                        currentInfo.oldMode = nextLine.slice(9, 16);\n                        currentInfo.newMode = lines[i + 2].slice(9, 16);\n                        i += 2;\n                        nextLine = lines[i + 1];\n                    }\n\n                    // read similarity\n                    if (nextLine.indexOf('similarity') === 0) {\n                        currentInfo.similarity = parseInt(nextLine.split(' ')[2], 10);\n                        i += 1;\n                    }\n\n                    // read similarity type and index\n                    var simiLine;\n                    simiLoop: while ((simiLine = lines[++i])) {\n                        var segs = simiLine.split(' ');\n\n                        switch (segs[0]) {\n                            case 'diff': // diff --git\n                                i--;\n                                break simiLoop;\n\n                            case 'index':\n                                var revs = segs[1].split('..');\n                                currentInfo.oldRevision = revs[0];\n                                currentInfo.newRevision = revs[1];\n\n                                if (segs[2]) {\n                                    currentInfo.oldMode = currentInfo.newMode = segs[2];\n                                }\n                                stat = STAT_HUNK;\n\n                                var oldFileName = lines[i + 1];\n                                if (oldFileName.indexOf('---') === 0) {\n                                    var newFileName = lines[i + 2];\n\n                                    if (/\\s\\/dev\\/null$/.test(oldFileName)) {\n                                        currentInfo.oldPath = '/dev/null';\n                                        currentInfoType = 'add';\n                                    }\n                                    else if (/\\s\\/dev\\/null$/.test(newFileName)) {\n                                        currentInfo.newPath = '/dev/null';\n                                        currentInfoType = 'delete';\n                                    }\n\n                                    i += 2;\n                                }\n\n                                break simiLoop;\n\n                        }\n\n                        if (!currentInfoType) {\n                            currentInfoType = segs[0];\n                        }\n                    }\n\n                    currentInfo.type = currentInfoType || 'modify';\n                }\n                else if (line.indexOf('Binary') === 0) {\n                    currentInfo.isBinary = true;\n                    currentInfo.type = line.indexOf('/dev/null and') >= 0\n                        ? 'add'\n                        : (line.indexOf('and /dev/null') >= 0 ? 'delete' : 'modify');\n                    stat = STAT_START;\n                    currentInfo = null;\n                }\n                else if (stat === STAT_HUNK) {\n                    if (line.indexOf('@@') === 0) {\n                        var match = /^@@\\s+-([0-9]+)(,([0-9]+))?\\s+\\+([0-9]+)(,([0-9]+))?/.exec(line)\n                        currentHunk = {\n                            content: line,\n                            oldStart: match[1] - 0,\n                            newStart: match[4] - 0,\n                            oldLines: match[3] - 0 || 1,\n                            newLines: match[6] - 0 || 1,\n                            changes: []\n                        };\n\n                        currentInfo.hunks.push(currentHunk);\n                        changeOldLine = currentHunk.oldStart;\n                        changeNewLine = currentHunk.newStart;\n                    }\n                    else {\n                        var typeChar = line.slice(0, 1);\n                        var change = {\n                            content: line.slice(1)\n                        };\n\n                        switch (typeChar) {\n                            case '+':\n                                change.type = 'insert';\n                                change.isInsert = true;\n                                change.lineNumber = changeNewLine;\n                                changeNewLine++;\n                                break;\n\n                            case '-':\n                                change.type = 'delete';\n                                change.isDelete = true;\n                                change.lineNumber = changeOldLine;\n                                changeOldLine++;\n                                break;\n\n                            case ' ':\n                                change.type = 'normal';\n                                change.isNormal = true;\n                                change.oldLineNumber = changeOldLine;\n                                change.newLineNumber = changeNewLine;\n                                changeOldLine++;\n                                changeNewLine++;\n                                break;\n\n                            case '\\\\': // Seems \"no newline\" is the only case starting with /\n                                var lastChange = currentHunk.changes[currentHunk.changes.length - 1];\n                                if (!lastChange.isDelete) {\n                                    currentInfo.newEndingNewLine = false;\n                                }\n                                if (!lastChange.isInsert) {\n                                    currentInfo.oldEndingNewLine = false;\n                                }\n                        }\n\n                        change.type && currentHunk.changes.push(change);\n                    }\n                }\n\n                i++;\n            }\n\n            return infos;\n        }\n    };\n\n    if (typeof exports === 'object' && typeof module === 'object') {\n        // For CommonJS\n        exports = module.exports = parser;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // For AMD\n        define('gitDiffParser', [], parser);\n    }\n    else {\n        root.gitDiffParser = parser;\n    }\n})(this);\n","import parser from 'gitdiff-parser';\nimport warning from 'warning';\n\nconst zipChanges = changes => {\n    const [result] = changes.reduce(\n        ([result, last, lastDeletionIndex], current, i) => {\n            if (!last) {\n                result.push(current);\n                return [result, current, current.isDelete ? i : -1];\n            }\n\n            if (current.isInsert && lastDeletionIndex >= 0) {\n                result.splice(lastDeletionIndex + 1, 0, current);\n                // The new `lastDeletionIndex` may be out of range, but `splice` will fix it\n                return [result, current, lastDeletionIndex + 2];\n            }\n\n            result.push(current);\n\n            // Keep the `lastDeletionIndex` if there are lines of deletions,\n            // otherwise update it to the new deletion line\n            const newLastDeletionIndex = current.isDelete ? (last.isDelete ? lastDeletionIndex : i) : i;\n\n            return [result, current, newLastDeletionIndex];\n        },\n        [[], null, -1]\n    );\n    return result;\n};\n\nconst mapHunk = (hunk, options) => {\n    const changes = options.nearbySequences === 'zip' ? zipChanges(hunk.changes) : hunk.changes;\n\n    return {\n        ...hunk,\n        isPlain: false,\n        changes: changes\n    };\n};\n\nconst mapFile = (file, options) => {\n    const hunks = file.hunks.map(hunk => mapHunk(hunk, options));\n\n    return {\n        ...file,\n        hunks: options.stubHunk ? addStubHunk(hunks) : hunks\n    };\n};\n\nconst normalizeDiffText = text => {\n    if (text.indexOf('diff --git') === 0) {\n        return text;\n    }\n\n    const indexOfFirstLineBreak = text.indexOf('\\n');\n    const indexOfSecondLineBreak = text.indexOf('\\n', indexOfFirstLineBreak + 1);\n    const firstLine = text.slice(0, indexOfFirstLineBreak);\n    const secondLine = text.slice(indexOfFirstLineBreak + 1, indexOfSecondLineBreak);\n    const oldPath = firstLine.slice(4);\n    const newPath = secondLine.slice(4);\n    const segments = [\n        `diff --git ${oldPath} ${newPath}`,\n        'index 1111111..2222222 100644',\n        text\n    ];\n\n    return segments.join('\\n');\n};\n\nexport const parseDiff = (text, options = {}) => {\n    warning(\n        !options.stubHunk,\n        'stubHunk options is deprecated, use addStubHunk function later to add a stub hunk, '\n        + 'this function can receive an extra referenceCodeOrLines argument to determine whether stub hunk is required'\n    );\n\n    const diffText = normalizeDiffText(text);\n    const files = parser.parse(diffText);\n\n    return files.map(file => mapFile(file, options));\n};\n\nexport const addStubHunk = (hunks, referenceCodeOrLines) => {\n    if (!hunks || !hunks.length) {\n        return hunks;\n    }\n\n    const isStubRequired = (() => {\n        if (!referenceCodeOrLines) {\n            return true;\n        }\n\n        const linesOfCode = typeof referenceCodeOrLines === 'string'\n            ? referenceCodeOrLines.split('\\n')\n            : referenceCodeOrLines;\n        const lastHunk = hunks[hunks.length - 1];\n        const lastLineNumber = lastHunk.oldStart + lastHunk.oldLines - 1;\n\n        return linesOfCode.length > lastLineNumber;\n    })();\n\n    if (!isStubRequired) {\n        return hunks;\n    }\n\n    const {oldStart, oldLines, newStart, newLines} = hunks[hunks.length - 1];\n    const stubHunk = {\n        oldStart: oldStart + oldLines,\n        oldLines: 0,\n        newStart: newStart + newLines,\n        newLines: 0,\n        content: 'STUB',\n        changes: []\n    };\n    return [...hunks, stubHunk];\n};\n"],"sourceRoot":""}